= Forklift
Matt Conroy<dcshock@gmail.com>, @David Thompson <dthompsn1@gmail.com>
v1.0, 2015-02-14
:library: Asciidoctor
:imagesdir: images
:homepage: https://github.com/dcshock/forklift

:toc: macro
toc::[]

== Forklift as an Enterprise Service Bus

An Enterprise Service Bus is used to coordinate communications between multiple
services in a service oriented architecture (SOA). ESB's try to simplify large
complex problems into smaller independent problems that can be devised, built,
and maintained independently.

A large portion of an ESB is a message broker that can queue messages and
distribute them to other services that need to receive them. Many brokers
exist today, ActiveMQ, RabbitMQ, Apache Kafka, etc. They can be setup to support
the enterprise customer's needs by adding functionality such as persisting
messages (guarantee delivery) and providing redundancy. Since they
concentrate on message delivery, their performance can be tuned to provide
very high message delievery rates.

Several message protocols for sending messages to these brokers exist,
including Stomp, JMS, and AMQP. There are APIs for different languages to
produce and consume messages to/from the brokers.

Applications can be written to communicate with the broker in both synchronous
and asynchronous fashions and perform work based on the messages queued. One
of the benefits of a message broker is that applications can be highly reactive
by just listening on message queues. When a message arrives to the broker, the
broker pushes the message to the application.

=== Microservices

Now along comes microservices. Microservices try to solve the same problem by
writing small independent applications to perform specific functions really
well. Then the microservices are brought together to solve a larger problem.
Typically microservices communicate together either via web-services or through
message passing through a broker.

=== Making it Easier

One of the benefits of microservices is that it is easier to write a bunch
of smaller applications and the applications can be isolated from one another.
However, one of the drawbacks is that it makes it harder to leverage common
functionality that can be shared between the two. Forklift allows
the developer to write microservices very quickly and benefit from
having some common functionality that all services can use.

=== Prime Functions

Forklift performs the the following prime duties of an ESB of:

* An abstraction layer provided for sub-components
* Control deployment and versioning of services
* Marshal use of redundant services
* Data transformation and mapping
* Security and exception handling

The other requirements of and ESB are met by the use of a broker such as
ActiveMQ. The following diagram shows how Forklift with a message broker
combine to form an ESB.

image::forklift-diagram-1.png[650,650,caption="Diagram 1. ",title="Forklift ESB"]


=== Language Support

Forklift is written in Java and and its consumers are to be written in Java.
_(can we say this will work with other JVM languages that can be loaded as a
jar?)_
However, it can consume messages that are placed on a message queue written
in any language and can use any of the standard Java communication protocols
to communicate to other services.

== What Forklift is Not

Purposely, Forklift is built to quickly create consumers in code to perform
actions based on messages. There is no xml configuration, there is no
business process modeling, no developed flow tools. It is built for developers
who can read/write code to implement redundant, retry capable, provable,
testable, queued, message processing.

== What Forklift Provides

=== Quick Deployment

Just like a Java based application server, Forklift can be started up all on
its own to do nothing. It doesn't start processing anything until a consumer
is deployed to it. Consumers are written to identify which queue/topic they will
consume. A method within the class must be designated to process the messages and
is run each time a new message is available. Other features such as designating
methods to validate the messages can easily be added. Failed
validation is handled by the Error Handler, see Standardized
Exception/Error Handling.

=== Easy Configuration

The way that Forklift provides easy configuration is by using a set of Java Annotations
provided by the system to wrap your business logic with core code to handle all
the routine things provided by Forklift. Here are a few examples of annotations
that provide functionality:

* @Queue - specified on a class given a name will begin processing any messages on the
named queue and running specified methods on the messages
* @OnMessage - specified on a method designates the method that should process every
time a message is received.
* @Message - Specified on a property of the class will try and inject the received message
into the property to be used to read the message contents easily.

=== Extendible

Forklift provides a method to extend the base life-cycle functionality using plug-ins.
There are several plug-ins that have already been developed, for example, the way to
have a message retry on error, or create audit logs that store an entire message that
can be replayed.

=== Message Lifecycle

Years of development experience led to Forklift being developed. Forklift needed to process
messages asynchronously, but end-users wanted to know exactly what happened with each of their
messages. After many discussions, the developers decided on the following minimal life-cycle processing
for each message.

image::forklift-message-lifecycle.png[707,540,caption="Diagram 2. ",title="Forklift Lifecycle"]

* Pending - Message has been picked up from the broker and is going to passed onto the consumer.
* Validating - Forklift will start running any @OnValidate methods to validate the message.
* Processing - Forklift is going to run any @OnMessage methods within the consumer to process the
message.
* Complete - Forklift successfully validated and processed the message without error.
* Invalid - Validation did not succeed successfully so the message won't be processed.
* Error - Validation may have succeeded but some other type of error occurred while processing the
message with the consumer.

Since the life-cycle is built for the developer to be able to track processing, Forklift
provides the ability to intercept each step. Components written and installed within
Forklift can add the @LifeCycle annotation on methods to have targeted code run when
messages reach each step. With this ability, it is quite easy to write specialized
message life-cycle auditing. Plug-ins are available that intercept the life-cycle to be
able to replay messages or allow for retrying a message in the event that a message
errors during processing.

==== Broker Consumer Related Configuration
The purpose of a consumer is to process messages off of queues or topics from the
broker. To make this easier, Forklift provides easy configuration of the consumer
by annotating the consumer Java class with annotations:

* @Queue - All messages placed on the named queue will be passed to this consumer.
* @Topic - All messages placed on the named topic will be passed to this consumer.
* @MultiThread - Forklift will run the specified number of consumers to process
messages off the queue when needed. Helps when consumers may be longer running
processes.
* @Order - TBD
* @RequireSystem - TBD

While making it easy to consume messages, it is also easy to configure the
consumer. Properties files containing data values that can be picked up by
the consumer at run-time can be deployed independently of the consumer. This
provides a quick way to deploy the same consumer in different environments (such as
production or test) and just change the properties for different behavior.
Files with the file extension .properties placed in the deployment directory will
be scanned and made available to the consumers.

@Named @Entity and other Spring configurable objects. - TBD

=== Marshalling of Messages to Objects
A lot of the base code when dealing JMS messages from Java involves marshaling
the message from the message into a usable object that can then just be used.
Forklift provides nice annotations that can be placed on properties to do
all this marshaling for you.

* @Config - Place this annotation on a java.util.Properties object.
All properties deployed properties files are made available for use.
* @Message - Placed on different property types, this will try and
marshal the message data into the object.
* @Headers - Placed on a Map of string and object, Forklift will marshal
the message headers into the map.
* @Properties - Placed on a Map of string and object, Forklift will marshal
the message properties into the map.

@Inject - TBD

=== Standardized Exception/Error Handling
In helping the developer organize their code and inject code into the life-cycle,
the developer can easily write message validation routines that can run
before the message processing is started. Forklift provides an annotation
to easily provide this functionality.

* @OnValidate - Place this annotation on methods to validate the message. Any
method that fails to validate will stop processing of the message and send
the life-cycle to the Invalid state.

If a consumer errors (throwing an exception - Checked or Runtime), Forklift
will automatically route the life-cycle to the Error state. This event can
then be hooked to show the errors. For more information on logging and
auditing see information about some of the plug-ins that have been built.

=== Plug-ins
Forklift has been thoughtfully designed enough to allow developers to
extend the base functionality for message processing. One of the major
requirements when originally developing this system was the ability to
log/audit every step of the life-cycle. However, every developer has
different logging requirements, whether that be logging to a file or sending
all logs to a database table. So integrating a single solution for auditing
did not make sense.

Several plug-ins have been developed that may be useful to other developers
for general use or as a template to build their own. These are part of
the Forklift project and are described below.

==== Specialized Message Handling

===== Retry Message Handler.
There are times when a consumer may not be able to successfully complete
processing a message. Say for example that a message is placed on the queue
and the data is to be pushed to a remote web-service. Of course the consumer
could write all the code to send the message, catch any exceptions and then
retry if it fails. Problem is, threads get bogged down doing retries and there
is no record of failed attempts. The retry message handler adds an annotation
that can be placed on the consumer that instructs Forklift on failure of
consuming a message to schedule to retry processing the message a set
number of times after a specified delay.

* @Retry - Placed on the consumer class will tell Forklift to reschedule
the message to be rerun if it errors.

===== Notifications - TBD
The best coders in the world can't guard against every last possible situation
that may arise in code. In a past life, we had a developer named Dan that
stated that a specific error case could never-ever happen. We called it the
DanException. Guess what--we did eventually see the DanException. The problem
was that even though we coded for it--we didn't have a way to handle it.
The Notification plug-in provides a way for a single consumer to intercept
the life-cycle and perform a specified notification when the life-cycle
event happens. For example, it is possible to write an Email notification
handler and then easily add to the consumer the ability to send an
email notification to a specific email address when a consumer Errors within
the life-cycle.

* @Notify - Placed on the consumer class will tell Forklift to send the
specified notification when the consumer enters into the specified life-cycle
events.

===== Replay Auditing
One of the joys of auditing is seeing what actually happened when the system
executes. Being able to view the entire life-cycle on every message that
goes through a system provides some with a great sense of comfort. In the
case when a consumer errors, it may be for a reason outside the consumer's
control. In this case just being able to resend the message as it originally
existed, may allow it to process. The replay auditor provides a log of
every life-cycle event for each annotated consumer that can then be parsed
and used to recreate an event.

* @Replay - Placed on the consumer class will log out all the life-cycle
events to a log file with enough data to be able to replay the message. In
essence making it possible to resend a message that has already been processed.

## Quickstart Guide

Download the forklift-server-x.x.zip release.

unzip the download

cd into the unzipped directory

$ mkdir ~/forklift

$ mkdir ~/forklift/deploy

$ bin/forklift-server -monitor1 ~/forklift/deploy -url embedded

### Write Your First Consumer

The Maven build file for your first consumer, if you're into that kind of thing.

.pom.xml
[source,xml]
----
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>
  <groupId>forklift.consumer</groupId>
  <artifactId>MyExampleConsumer</artifactId>
  <version>0.0.1-SNAPSHOT</version>
  <name>My Example Consumer</name>
  <description>An example Forklift consumer.</description>
  <repositories>
    <repository>
        <id>oss-sonatype</id>
        <name>oss-sonatype</name>
        <url>https://oss.sonatype.org/content/repositories/snapshots/</url>
        <snapshots>
            <enabled>true</enabled>
        </snapshots>
    </repository>
</repositories>
  <dependencies>
    <dependency>
      <groupId>com.github.dcshock</groupId>
      <artifactId>forklift</artifactId>
      <version>0.5</version>
    </dependency>
  </dependencies>
</project>
----

The Sbt build file for your first consumer, if you're into that kind of thing.

.build.sbt
[source,sbt]
----
TBD
----

The source code for your first consumer

.MyExampleConsumer.java
[source,java]
----
package forklift.consumer;

import forklift.decorators.Message;
import forklift.decorators.OnMessage;
import forklift.decorators.Queue;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Map;

@Queue("test")
public class MyExampleConsumer {
    Logger log = LoggerFactory.getLogger(MyExampleConsumer.class);

    @Message
    public Map<String, String> msg;

    @OnMessage
    public void processMyMessage() {
        log.info("My message was: {}", msg);
    }
}
----

### Deploy Your Consumer

Now compile your first consumer and create a jar with the resulting class
file. Once the jar file is ready to go, just copy it to ~/forklift/deploy.

### Send a Message to Your Queue

Since we havne't installed the full ActiveMQ, then you need to install an interface
to send messages to your queue. There are several tools that can be used to do this
easily. Here are several:

* stomp.py - A Python library for sending messages to ActiveMQ that has the stomp
protocol enabled. Works okay for Json objects, but for K/V pairs needs modifications
since its not possible to send newline characters.
* stomp-client - For node.js, this client library can help easily send messages to
to ActiveMQ.
* Net::STOMP::Client - Perl library for working with communicating with the Stomp
protocol.
* forklift Producer - A little more heavy-weight since it is for Java, but uses the
same ActiveMQ connector that forklift uses. It is based on JMS not the Stomp protocol.
More information can be found outside the Quickstart guide.

Install node, stomp-client, modify frames.js,
Change

.frame.js
[source,javascript]
----
if (this.body.length > 0) {
----

to

.frame.js
[source,javascript]
----
if (this.body.length > 0 && !this.headers.hasOwnProperty("suppress-content-length")) {
----

write sendmessage.js. *TBD*

.sendmessage.js
[source,javascript]
----
var Stomp = require('stomp-client');
var dest = process.argv[2];
var client = new Stomp('localhost', 61613, null, null);

client.on('error', function(e) {
  console.log(e);
});

client.connect(function(sessionId) {
  var msg = process.argv[3];
  client.publish(dest, msg, {"suppress-content-length":"true", "persistent":"true"});
  client.disconnect();
});
----

From command line, run the node progam above. *TBD*

[source,bash]
----
$ node sender.js /queue/test $'test=val\nx=y\na=b'
----

## Consumer Development

## Server

## Connectors

### ActiveMQ JMS Connector
A very popular broker in the world of Java Messaging Services (JMS) is
Apache's ActiveMQ. Forklift has been used very successfully with ActiveMQ
as its primary broker. Forklift provides an out of the box connector for
immediate use with ActiveMQ (located in connectors/ActiveMQ).

### Others
Currently we have not written any other connectors, but it would be quite
easy to implement other connectors for other brokers such as ActiveMQ using
AMQP or perhaps RabbitMQ. We will extend this section as other connectors
become available.

## Plugins
